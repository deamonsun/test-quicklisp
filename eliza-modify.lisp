;; ????eliza-chinese 有个BUG
;; 发生在(pat-match::use-eliza-rules  '(你 好))  /= (use-eliza-rules  '(你 好))
;; 即从外部调用函数得到的结果（无法匹配）与包内调用不同。
;; 发现(pat-match::rule-pattern (nth 0 pat-match::*eliza-rules*)) ＝>
;; ((PAT-MATCH::?* PAT-MATCH::?X) PAT-MATCH::你 PAT-MATCH::好 (PAT-MATCH::?* PAT-MATCH::?Y))
;; 也即由于该程序的模式匹配基于符号对象是否相等"eq",但事实上，当从包外部访问时，本包内的所有符号将被加上前缀包名，故无法EQ。
;;(load "c:/Lisp-Enviroment/packages/eliza.lisp" :external-format :utf8)
(defpackage #:pat-match
  (:use #:cl)
  (:export :chat))

(in-package #:pat-match)

(defconstant fail nil)

(defconstant no-bindings '((t . t)))

(defun starts-with (list x)
  "Is this a list whose first element is x?"
  (and (consp list) (eql (first list) x)))

(defun variable-p (x)
  "Is x a variable (a symbol beginning with `?')?"
  (and (symbolp x) (equal (elt (symbol-name x) 0) #\?)))

(defun match-variable (var input bindings)
	     (let ((binding (get-binding var bindings)))
	       (cond ((not binding )(exte-bindings var input bindings))
		     ((equal input (binding-val binding)) bindings)
		     (t fail))))

(defun get-binding (var bindings)
	     (assoc var bindings))

(defun binding-val (binding)
	     (cdr binding))

(defun lookup (var bindings)
	     (binding-val (get-binding var bindings)))

(defun exte-bindings (var val bindings)
	     (cons (cons var val ) bindings))

;; 注意pat-match的结构，事实上即在表 pattern 和input之上递归地调用pat-match，以最终返回bindings结果值
;; 注意该定义的特别之处，在递归形式（最后一句）的第三个参数bindings形参处给以 (pat-match (first pattern) (first input) bindings)作为其第三个参数
;; 显见，对于此类需要树形递归以返回某个结果值（如bindings）的过程（如pat-match），将结果值作为递归过程的参数是有好处的，因为递归形式的该参数bindings位置可嵌套多层过程pat-match。这样做的好处是可以直接将bindings传递给下一次递归式(pat-match (rest pattern ...))。以实现在整个树上的递归。
;; 注意这类复杂递归与纯粹的尾递归之间的区别，显然复杂递归由于将结果值作为参数，其递归过程更易控制，且执行过程中变量、结果是可见的； 而纯粹尾递归更简洁，但其递归过程不可见，就如SCIP书所述，在递归链条中可能会丢失而无法追溯其过程和中间值。
;; 而cond的前几种情况即为定义在给定三种情况下对bindings值的操作,1.pattern 是一个变量，此情况对应(pat-match (first pattern)...)的可能情况； 2.(eql pattern input)此情况对应 (pat-match (first pattern) ...)和(pat-match (rest pattern) ...)的可能情况 3.(segment-pattern-p pattern) ,此情况对应 (pat-match (rest pattern) ...)的一种可能情况; 4.其余情况认为匹配失败，(pat-match (first pattern) ...)返回FAIL 或者 (pat-match (rest pattern) ...)返回FAIL

(defun pat-match (pattern input &optional (bindings no-bindings))
  "Match pattern against input in the context of the bindings"
  (cond ((equal bindings fail) fail)
        ((variable-p pattern)
         (match-variable pattern input bindings))
        ((equal pattern input) bindings)
        ((segment-pattern-p pattern)                ; ***
         (segment-match pattern input bindings))    ; ***
        ((and (consp pattern) (consp input)) 
         (pat-match (rest pattern) (rest input)
                    (pat-match (first pattern) (first input) 
                               bindings)))
        (t fail)))

(defun segment-pattern-p (pattern)
  "Is this a segment matching pattern: ((?* var) . pat)"
  (and (consp pattern)
       (starts-with (first pattern) '?*)))

;;; ==============================

(defun segment-match (pattern input bindings &optional (start 0))
  "Match the segment pattern ((?* var) . pat) against input."
  (let ((var (second (first pattern)))
        (pat (rest pattern)))
    (if (null pat)
        (match-variable var input bindings)
        ;; We assume that pat starts with a constant
        ;; In other words, a pattern can't have 2 consecutive vars
        (let ((pos (position (first pat) input
                             :start start :test #'equal)))
          (if (null pos)
              fail
              (let ((b2 (pat-match pat (subseq input pos) bindings)))
                ;; If this match failed, try another longer one
                ;; If it worked, check that the variables match
                (if (equal b2 fail)
                    (segment-match pattern input bindings (+ pos 1))
                    (match-variable var (subseq input 0 pos) b2))))))))

;;; ==============================

(defun segment-match (pattern input bindings &optional (start 0))
  "Match the segment pattern ((?* var) . pat) against input."
  (let ((var (second (first pattern)))
        (pat (rest pattern)))
    (if (null pat)
        (match-variable var input bindings)
        ;; We assume that pat starts with a constant
        ;; In other words, a pattern can't have 2 consecutive vars
        (let ((pos (position (first pat) input
                             :start start :test #'equal)))
          (if (null pos)
              fail
              (let ((b2 (pat-match
                          pat (subseq input pos)
                          (match-variable var (subseq input 0 pos)
                                          bindings))))
                ;; If this match failed, try another longer one
                (if (equal b2 fail)
                    (segment-match pattern input bindings (+ pos 1))
                    b2)))))))

;;; ==============================

(defun rule-pattern (rule) (first rule))
(defun rule-responses (rule) (rest rule))

;;; ==============================

(defparameter *eliza-rules*
 '((((?* ?x) hello (?* ?y))      
    (How do you do.  Please state your problem.))
   (((?* ?x) I want (?* ?y))     
    (What would it mean if you got ?y)
    (Why do you want ?y) (Suppose you got ?y soon))
   (((?* ?x) if (?* ?y)) 
    (Do you really think its likely that ?y) (Do you wish that ?y)
    (What do you think about ?y) (Really-- if ?y))
   (((?* ?x) no (?* ?y))
    (Why not?) (You are being a bit negative)
    (Are you saying "NO" just to be negative?))
   (((?* ?x) I was (?* ?y))       
    (Were you really?) (Perhaps I already knew you were ?y)
    (Why do you tell me you were ?y now?))
   (((?* ?x) I feel (?* ?y))     
    (Do you often feel ?y ?))
   (((?* ?x) I felt (?* ?y))     
    (What other feelings do you have?))))

;;; ==============================

(defun eliza ()
  "Respond to user input using pattern matching rules."
  (loop
    (print 'eliza>)
    (write (flatten (use-eliza-rules (read))) :pretty t)))

(defun use-eliza-rules (input)
  "Find some rule with which to transform the input."
  (some #'(lambda (rule) 
            (let ((result (pat-match (rule-pattern rule) input)))
              (if (not (eq result fail))
                  (sublis (switch-viewpoint result)
                          (random-elt (rule-responses rule))))))
        *eliza-rules*))

(defun switch-viewpoint (words)
  "Change I to you and vice versa, and so on."
  (sublis '((I . you) (you . I) (me . you) (am . are))
          words))

;;; ==============================

(defun flatten (the-list)
  "Append together elements (or lists) in the list."
  (mappend #'mklist the-list))

(defun mklist (x)
  "Return x if it is a list, otherwise (x)."
  (if (listp x)
      x
      (list x)))

(defun mappend (fn the-list)	
  "Apply fn to each element of list and append the results."
  (apply #'append (mapcar fn the-list)))

(defun random-elt (choices)
  "Choose an element from a list at random."
  (elt choices (random (length choices))))

(defun read-line-no-punct ()
  "Read an input line, ignoring punctuation."
  (read-from-string
    (concatenate 'string "(" (substitute-if #\space #'punctuation-p
                                            (read-line))
                 ")")))

(defun punctuation-p (char) (find char ".,;:`!?#-()\\\""))

;;; ==============================

(defun eliza ()
  "Respond to user input using pattern matching rules."
  (loop
    (print 'eliza>)
    (let* ((input (read-line-no-punct))
           (response (flatten (use-eliza-rules input))))
      (print-with-spaces response)
      (if (equal response '(good bye)) (RETURN)))))

(defun print-with-spaces (list)
  (mapc #'(lambda (x) (prin1 x) (princ " ")) list))

(defun print-with-spaces (list)
  (format t "~{~a ~}" list))

;;; ==============================

(defun mappend (fn &rest lists)	
  "Apply fn to each element of lists and append the results."
  (apply #'append (apply #'mapcar fn lists)))

;;; ==============================

(defparameter *eliza-rules*
 '((((?* ?x) hello (?* ?y))      
    (How do you do.  Please state your problem.))
   (((?* ?x) computer (?* ?y))
    (Do computers worry you?) (What do you think about machines?)
    (Why do you mention computers?)
    (What do you think machines have to do with your problem?))
   (((?* ?x) name (?* ?y))
    (I am not interested in names))
   (((?* ?x) sorry (?* ?y))
    (Please don't apologize) (Apologies are not necessary)
    (What feelings do you have when you apologize))
   (((?* ?x) I remember (?* ?y)) 
    (Do you often think of ?y)
    (Does thinking of ?y bring anything else to mind?)
    (What else do you remember) (Why do you recall ?y right now?)
    (What in the present situation reminds you of ?y)
    (What is the connection between me and ?y))
   (((?* ?x) do you remember (?* ?y))
    (Did you think I would forget ?y ?)
    (Why do you think I should recall ?y now)
    (What about ?y) (You mentioned ?y))
   (((?* ?x) if (?* ?y)) 
    (Do you really think its likely that ?y) (Do you wish that ?y)
    (What do you think about ?y) (Really-- if ?y))

   (((?* ?x) I dreamt (?* ?y))
    (Really-- ?y) (Have you ever fantasized ?y while you were awake?)
    (Have you dreamt ?y before?))
   (((?* ?x) dream about (?* ?y))
    (How do you feel about ?y in reality?))
   (((?* ?x) dream (?* ?y))    
    (What does this dream suggest to you?) (Do you dream often?)
    (What persons appear in your dreams?)
    (Don't you believe that dream has to do with your problem?))
   (((?* ?x) my mother (?* ?y))
    (Who else in your family ?y) (Tell me more about your family))
   (((?* ?x) my father (?* ?y))
    (Your father) (Does he influence you strongly?) 
    (What else comes to mind when you think of your father?))

   (((?* ?x) I want (?* ?y))     
    (What would it mean if you got ?y)
    (Why do you want ?y) (Suppose you got ?y soon))
   (((?* ?x) I am glad (?* ?y))
    (How have I helped you to be ?y) (What makes you happy just now)
    (Can you explain why you are suddenly ?y))
   (((?* ?x) I am sad (?* ?y))
    (I am sorry to hear you are depressed)
    (I'm sure its not pleasant to be sad))
   (((?* ?x) are like (?* ?y))   
    (What resemblance do you see between ?x and ?y))
   (((?* ?x) is like (?* ?y))    
    (In what way is it that ?x is like ?y)
    (What resemblance do you see?)
    (Could there really be some connection?) (How?))
   (((?* ?x) alike (?* ?y))      
    (In what way?) (What similarities are there?))
   (((?* ?x) same (?* ?y))       
    (What other connections do you see?))

   (((?* ?x) I was (?* ?y))       
    (Were you really?) (Perhaps I already knew you were ?y)
    (Why do you tell me you were ?y now?))
   (((?* ?x) was I (?* ?y))
    (What if you were ?y ?) (Do you thin you were ?y)
    (What would it mean if you were ?y))
   (((?* ?x) I am (?* ?y))       
    (In what way are you ?y) (Do you want to be ?y ?))
   (((?* ?x) am I (?* ?y))
    (Do you believe you are ?y) (Would you want to be ?y)
    (You wish I would tell you you are ?y)
    (What would it mean if you were ?y))
   (((?* ?x) am (?* ?y))
    (Why do you say "AM?") (I don't understand that))
   (((?* ?x) are you (?* ?y))
    (Why are you interested in whether I am ?y or not?)
    (Would you prefer if I weren't ?y)
    (Perhaps I am ?y in your fantasies))
   (((?* ?x) you are (?* ?y))   
    (What makes you think I am ?y ?))

   (((?* ?x) because (?* ?y))
    (Is that the real reason?) (What other reasons might there be?)
    (Does that reason seem to explain anything else?))
   (((?* ?x) were you (?* ?y))
    (Perhaps I was ?y) (What do you think?) (What if I had been ?y))
   (((?* ?x) I can't (?* ?y))    
    (Maybe you could ?y now) (What if you could ?y ?))
   (((?* ?x) I feel (?* ?y))     
    (Do you often feel ?y ?))
   (((?* ?x) I felt (?* ?y))     
    (What other feelings do you have?))
   (((?* ?x) I (?* ?y) you (?* ?z))   
    (Perhaps in your fantasy we ?y each other))
   (((?* ?x) why don't you (?* ?y))
    (Should you ?y yourself?)
    (Do you believe I don't ?y) (Perhaps I will ?y in good time))
   (((?* ?x) yes (?* ?y))
    (You seem quite positive) (You are sure) (I understand))
   (((?* ?x) no (?* ?y))
    (Why not?) (You are being a bit negative)
    (Are you saying "NO" just to be negative?))

   (((?* ?x) someone (?* ?y))
    (Can you be more specific?))
   (((?* ?x) everyone (?* ?y))
    (surely not everyone) (Can you think of anyone in particular?)
    (Who for example?) (You are thinking of a special person))
   (((?* ?x) always (?* ?y))
    (Can you think of a specific example) (When?)
    (What incident are you thinking of?) (Really-- always))
   (((?* ?x) what (?* ?y))
    (Why do you ask?) (Does that question interest you?)
    (What is it you really want to know?) (What do you think?)
    (What comes to your mind when you ask that?))
   (((?* ?x) perhaps (?* ?y))    
    (You do not seem quite certain))
   (((?* ?x) are (?* ?y))
    (Did you think they might not be ?y)
    (Possibly they are ?y))
   (((?* ?x))               
    (Very interesting) (I am not sure I understand you fully)
    (What does that suggest to you?) (Please continue) (Go on) 
    (Do you feel strongly about discussing such things?))))

(defun switch-viewpoint (words)
	     (sublis '((I . you) (you . i) (me . you) (am . are)
		       (我 . 你) (我们 . 你们) (你 . 我) (你们 . 我们  ))
		     words))

(defun print-eliza-response (the-list)
  (format t 
	     (reduce #'(lambda (a b) (concatenate 'string a b ))
		      (mapcar #'string  the-list))))

(defun eliza-chinese ()
	       (loop 
		    (print '艾丽莎>)
		  (print-eliza-response
		   (or (flatten (use-eliza-rules 
				   (mapcar #'read-from-string
					   (cl-ppcre:split "\\s*"  
							   (let ((ss  (read-line *query-io* )))
							     (if (equal ss "再见") (return)
								 ss))))))
		       '(无话可说)))))

(defparameter *eliza-rules*
	     '((((?* ?x) "你" "好" (?* ?y))      
		("你好。很高兴见到你" ))
	       (((?* ?x ) "名" "字" (?* ?y))
		("我对名字不感兴趣"))
	       (((?* ?x) "抱" "歉" (?* ?y))
		("请别道歉") ("没必要道歉")
		("你道歉时是怎么想的"))
	       (((?* ?x) "我" "记" "得" (?* ?y))
		("你经常想起" ?y "吗")
		("想起" ?y "有什么意义吗")
		("你还记得什么")
		("为什么你现在会想起" ?y)
		(?y "和我有什么关系"))
	       (((?* ?x) "你" "记" "得" "吗" (?* ?y))
		("你觉得我会忘记" ?y "吗")
		("你是说" ?y "?"))
	       (((?* ?x) "如" "果" (?* ?y))
		("你真的认为" ?y)
		("你希望" ?y "吗")
		("真的吗?" "如果" ?y))
	       (((?* ?x) "我" "幻" "想" (?* ?y))	       
		("真的吗？" ?y)
		("你清醒的时候会想象" ?y "吗？"))
	       (((?* ?x) "梦" (?* ?y))
		("这些梦暗示你什么？")("你经常做梦吗？")
		("你梦里出现哪些人？"))
	       (((?* ?x) "我" "妈" (?* ?y))
		("你家里还有什么人？")
		("多聊聊你的家人"))
	       (((?* ?x) "我" "爸" (?* ?y))
		("他对你影响很多吗？"))
	       (((?* ?x) "我" "想" "要" (?* ?y))
		("你为什么想要" ?y)
		("想象你马上就要" ?y))
	       (((?* ?x) "因" "为" (?* ?y))
		("那是真正的原因吗？"))
	       (((?* ?x) "你" "是" "不" "是" (?* ?y))
		("也许我是" ?y))
	       (((?* ?x) "我" "不" "能" (?* ?y))
		("也许你现在已经可以" ?y))
	       (((?* ?x) "我" "觉" "得" (?* ?y))
		("你经常觉得" ?y "吗？"))
	       (((?* ?x) "我" (?* ?y) "你"  (?* ?z))
		("也许你想象我们彼此" ?y ))
	       (((?* ?x) "你" "干" "吗" "不" (?* ?y))
		("你自己会" ?y "吗？"))
	       (((?* ?x) "不" (?* ?y))
		("为什么不？")("你有点消极了"))
	       (((?* ?x))
		("很有趣")("我想我还不够了解你")
		("那对你来说意味着什么？")("接着说")("继续吧")
		("你对这些感受很深吗？"))
		))


(defun chat1 (str)
	(apply #'str:concat       (flatten (use-eliza-rules 
					   (cl-ppcre:split "\\s*"  str)))))
